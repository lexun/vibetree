use anyhow::{Context, Result};
use std::collections::HashMap;
use std::fs;
use std::path::Path;

pub struct EnvFileGenerator;

impl EnvFileGenerator {
    pub fn generate_env_file(
        worktree_path: &Path,
        branch_name: &str,
        ports: &HashMap<String, u16>,
        env_var_names: &HashMap<String, String>,
    ) -> Result<()> {
        let vibetree_dir = worktree_path.join(".vibetree");
        fs::create_dir_all(&vibetree_dir).with_context(|| {
            format!(
                "Failed to create .vibetree directory: {}",
                vibetree_dir.display()
            )
        })?;

        let env_file_path = vibetree_dir.join("env");
        let content = Self::build_env_content(branch_name, ports, env_var_names);

        fs::write(&env_file_path, content)
            .with_context(|| format!("Failed to write env file: {}", env_file_path.display()))?;

        Ok(())
    }

    pub fn suggest_gitignore_update(worktree_path: &Path) -> Result<bool> {
        let gitignore_path = worktree_path.join(".gitignore");

        if !gitignore_path.exists() {
            return Ok(false);
        }

        let existing_content = fs::read_to_string(&gitignore_path)
            .with_context(|| format!("Failed to read .gitignore: {}", gitignore_path.display()))?;

        if existing_content.contains(".vibetree/") {
            return Ok(true); // Already present
        }

        Ok(false) // Needs to be added
    }

    pub fn add_to_gitignore(worktree_path: &Path) -> Result<()> {
        let gitignore_path = worktree_path.join(".gitignore");

        let mut content = if gitignore_path.exists() {
            fs::read_to_string(&gitignore_path).with_context(|| {
                format!("Failed to read .gitignore: {}", gitignore_path.display())
            })?
        } else {
            String::new()
        };

        if !content.contains(".vibetree/") {
            if !content.is_empty() && !content.ends_with('\n') {
                content.push('\n');
            }
            content.push_str("# Vibetree worktree metadata\n.vibetree/\n");

            fs::write(&gitignore_path, content).with_context(|| {
                format!("Failed to write .gitignore: {}", gitignore_path.display())
            })?;
        }

        Ok(())
    }

    fn build_env_content(
        branch_name: &str,
        ports: &HashMap<String, u16>,
        env_var_names: &HashMap<String, String>,
    ) -> String {
        let mut content = String::new();

        content.push_str("# Generated by vibetree - DO NOT EDIT MANUALLY\n");
        content.push_str(&format!("# Managed by: vibetree v{}\n\n", crate::VERSION));

        // Add service ports
        let mut sorted_services: Vec<_> = ports.iter().collect();
        sorted_services.sort_by_key(|(service, _)| *service);

        for (service, port) in sorted_services {
            let env_var = Self::service_to_env_var(service, env_var_names);
            content.push_str(&format!("{}={}\n", env_var, port));
        }

        content.push('\n');
        content.push_str("# Worktree metadata\n");
        content.push_str(&format!("VIBETREE_BRANCH={}\n", branch_name));

        content
    }

    fn service_to_env_var(service: &str, env_var_names: &HashMap<String, String>) -> String {
        // Check if there's a custom environment variable name configured
        if let Some(custom_name) = env_var_names.get(service) {
            custom_name.clone()
        } else {
            // Fallback to the standard pattern: SERVICE_PORT
            format!("{}_PORT", service.to_uppercase())
        }
    }

    pub fn read_env_file(worktree_path: &Path) -> Result<HashMap<String, String>> {
        let env_file_path = worktree_path.join(".vibetree").join("env");

        if !env_file_path.exists() {
            return Ok(HashMap::new());
        }

        let content = fs::read_to_string(&env_file_path)
            .with_context(|| format!("Failed to read env file: {}", env_file_path.display()))?;

        let mut env_vars = HashMap::new();
        for line in content.lines() {
            let line = line.trim();
            if line.is_empty() || line.starts_with('#') {
                continue;
            }

            if let Some((key, value)) = line.split_once('=') {
                env_vars.insert(key.to_string(), value.to_string());
            }
        }

        Ok(env_vars)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashMap;
    use tempfile::TempDir;

    #[test]
    fn test_generate_env_file() -> Result<()> {
        let temp_dir = TempDir::new()?;
        let worktree_path = temp_dir.path();

        let mut ports = HashMap::new();
        ports.insert("postgres".to_string(), 5433);
        ports.insert("redis".to_string(), 6380);
        ports.insert("api".to_string(), 8001);

        let mut env_var_names = HashMap::new();
        env_var_names.insert("postgres".to_string(), "PGPORT".to_string());
        env_var_names.insert("redis".to_string(), "REDIS_PORT".to_string());
        env_var_names.insert("api".to_string(), "API_PORT".to_string());

        EnvFileGenerator::generate_env_file(worktree_path, "test-branch", &ports, &env_var_names)?;

        let env_file_path = worktree_path.join(".vibetree").join("env");
        assert!(env_file_path.exists());

        let content = fs::read_to_string(&env_file_path)?;
        assert!(content.contains("PGPORT=5433"));
        assert!(content.contains("REDIS_PORT=6380"));
        assert!(content.contains("API_PORT=8001"));
        assert!(content.contains("VIBETREE_BRANCH=test-branch"));
        assert!(content.contains("# Generated by vibetree"));

        Ok(())
    }

    #[test]
    fn test_read_env_file() -> Result<()> {
        let temp_dir = TempDir::new()?;
        let worktree_path = temp_dir.path();

        let mut ports = HashMap::new();
        ports.insert("postgres".to_string(), 5433);
        ports.insert("redis".to_string(), 6380);

        let mut env_var_names = HashMap::new();
        env_var_names.insert("postgres".to_string(), "PGPORT".to_string());
        env_var_names.insert("redis".to_string(), "REDIS_PORT".to_string());

        EnvFileGenerator::generate_env_file(worktree_path, "test-branch", &ports, &env_var_names)?;

        let env_vars = EnvFileGenerator::read_env_file(worktree_path)?;

        assert_eq!(env_vars.get("PGPORT"), Some(&"5433".to_string()));
        assert_eq!(env_vars.get("REDIS_PORT"), Some(&"6380".to_string()));
        assert_eq!(
            env_vars.get("VIBETREE_BRANCH"),
            Some(&"test-branch".to_string())
        );

        Ok(())
    }

    #[test]
    fn test_service_to_env_var() {
        let mut env_var_names = HashMap::new();
        env_var_names.insert("postgres".to_string(), "PGPORT".to_string());
        env_var_names.insert("redis".to_string(), "REDIS_PORT".to_string());

        // Test custom mappings
        assert_eq!(
            EnvFileGenerator::service_to_env_var("postgres", &env_var_names),
            "PGPORT"
        );
        assert_eq!(
            EnvFileGenerator::service_to_env_var("redis", &env_var_names),
            "REDIS_PORT"
        );

        // Test fallback behavior for unmapped services
        assert_eq!(
            EnvFileGenerator::service_to_env_var("api", &env_var_names),
            "API_PORT"
        );
        assert_eq!(
            EnvFileGenerator::service_to_env_var("my-custom-service", &env_var_names),
            "MY-CUSTOM-SERVICE_PORT"
        );
    }

    #[test]
    fn test_gitignore_operations() -> Result<()> {
        let temp_dir = TempDir::new()?;
        let worktree_path = temp_dir.path();

        // Test when .gitignore doesn't exist
        assert!(!EnvFileGenerator::suggest_gitignore_update(worktree_path)?);

        // Create a .gitignore without .vibetree/
        let gitignore_path = worktree_path.join(".gitignore");
        fs::write(&gitignore_path, "*.log\n")?;

        assert!(!EnvFileGenerator::suggest_gitignore_update(worktree_path)?);

        // Add .vibetree/ to .gitignore
        EnvFileGenerator::add_to_gitignore(worktree_path)?;

        let content = fs::read_to_string(&gitignore_path)?;
        assert!(content.contains(".vibetree/"));
        assert!(EnvFileGenerator::suggest_gitignore_update(worktree_path)?);

        // Test idempotency - adding again shouldn't duplicate
        EnvFileGenerator::add_to_gitignore(worktree_path)?;
        let _content_after = fs::read_to_string(&gitignore_path)?;
        assert_eq!(content.matches(".vibetree/").count(), 1);

        Ok(())
    }
}
