use anyhow::{Context, Result};
use std::collections::HashMap;
use std::fs;
use std::path::Path;

pub struct EnvFileGenerator;

impl EnvFileGenerator {
    pub fn generate_env_file(
        env_file_path: &Path,
        branch_name: &str,
        ports: &HashMap<String, u16>,
    ) -> Result<()> {
        if let Some(parent) = env_file_path.parent() {
            fs::create_dir_all(parent).with_context(|| {
                format!(
                    "Failed to create env file directory: {}",
                    parent.display()
                )
            })?;
        }

        let content = Self::build_env_content(branch_name, ports);

        fs::write(env_file_path, content)
            .with_context(|| format!("Failed to write env file: {}", env_file_path.display()))?;

        Ok(())
    }

    pub fn suggest_gitignore_update(worktree_path: &Path) -> Result<bool> {
        let gitignore_path = worktree_path.join(".gitignore");

        if !gitignore_path.exists() {
            return Ok(false);
        }

        let existing_content = fs::read_to_string(&gitignore_path)
            .with_context(|| format!("Failed to read .gitignore: {}", gitignore_path.display()))?;

        if existing_content.contains(".vibetree/") {
            return Ok(true); // Already present
        }

        Ok(false) // Needs to be added
    }

    pub fn add_to_gitignore(worktree_path: &Path) -> Result<()> {
        let gitignore_path = worktree_path.join(".gitignore");

        let mut content = if gitignore_path.exists() {
            fs::read_to_string(&gitignore_path).with_context(|| {
                format!("Failed to read .gitignore: {}", gitignore_path.display())
            })?
        } else {
            String::new()
        };

        if !content.contains(".vibetree/") {
            if !content.is_empty() && !content.ends_with('\n') {
                content.push('\n');
            }
            content.push_str("# Vibetree worktree metadata\n.vibetree/\n");

            fs::write(&gitignore_path, content).with_context(|| {
                format!("Failed to write .gitignore: {}", gitignore_path.display())
            })?;
        }

        Ok(())
    }

    fn build_env_content(
        _branch_name: &str,
        ports: &HashMap<String, u16>,
    ) -> String {
        let mut content = String::new();

        content.push_str("# Generated by vibetree - DO NOT EDIT MANUALLY\n");
        content.push_str(&format!("# Managed by: vibetree v{}\n\n", crate::VERSION));

        // Add variable ports - keys are already env var names
        let mut sorted_variables: Vec<_> = ports.iter().collect();
        sorted_variables.sort_by_key(|(env_var_name, _)| *env_var_name);

        for (env_var_name, port) in sorted_variables {
            content.push_str(&format!("{}={}\n", env_var_name, port));
        }


        content
    }


    pub fn read_env_file(env_file_path: &Path) -> Result<HashMap<String, String>> {
        if !env_file_path.exists() {
            return Ok(HashMap::new());
        }

        let content = fs::read_to_string(env_file_path)
            .with_context(|| format!("Failed to read env file: {}", env_file_path.display()))?;

        let mut env_vars = HashMap::new();
        for line in content.lines() {
            let line = line.trim();
            if line.is_empty() || line.starts_with('#') {
                continue;
            }

            if let Some((key, value)) = line.split_once('=') {
                env_vars.insert(key.to_string(), value.to_string());
            }
        }

        Ok(env_vars)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashMap;
    use tempfile::TempDir;

    #[test]
    fn test_generate_env_file() -> Result<()> {
        let temp_dir = TempDir::new()?;
        let worktree_path = temp_dir.path();

        let mut ports = HashMap::new();
        ports.insert("PGPORT".to_string(), 5433);
        ports.insert("REDIS_PORT".to_string(), 6380);
        ports.insert("API_PORT".to_string(), 8001);

        let env_file_path = worktree_path.join(".vibetree").join("env");
        EnvFileGenerator::generate_env_file(&env_file_path, "test-branch", &ports)?;

        assert!(env_file_path.exists());

        let content = fs::read_to_string(&env_file_path)?;
        assert!(content.contains("PGPORT=5433"));
        assert!(content.contains("REDIS_PORT=6380"));
        assert!(content.contains("API_PORT=8001"));
        assert!(content.contains("# Generated by vibetree"));

        Ok(())
    }

    #[test]
    fn test_read_env_file() -> Result<()> {
        let temp_dir = TempDir::new()?;
        let worktree_path = temp_dir.path();

        let mut ports = HashMap::new();
        ports.insert("PGPORT".to_string(), 5433);
        ports.insert("REDIS_PORT".to_string(), 6380);

        let env_file_path = worktree_path.join(".vibetree").join("env");
        EnvFileGenerator::generate_env_file(&env_file_path, "test-branch", &ports)?;

        let env_vars = EnvFileGenerator::read_env_file(&env_file_path)?;

        assert_eq!(env_vars.get("PGPORT"), Some(&"5433".to_string()));
        assert_eq!(env_vars.get("REDIS_PORT"), Some(&"6380".to_string()));

        Ok(())
    }


    #[test]
    fn test_custom_env_file_path() -> Result<()> {
        let temp_dir = TempDir::new()?;
        let worktree_path = temp_dir.path();

        let custom_env_path = worktree_path.join("custom").join("path").join(".env");

        let mut ports = HashMap::new();
        ports.insert("API_PORT".to_string(), 8080);

        EnvFileGenerator::generate_env_file(&custom_env_path, "test-branch", &ports)?;

        assert!(custom_env_path.exists());
        
        let content = fs::read_to_string(&custom_env_path)?;
        assert!(content.contains("API_PORT=8080"));

        let env_vars = EnvFileGenerator::read_env_file(&custom_env_path)?;
        assert_eq!(env_vars.get("API_PORT"), Some(&"8080".to_string()));

        Ok(())
    }

    #[test]
    fn test_gitignore_operations() -> Result<()> {
        let temp_dir = TempDir::new()?;
        let worktree_path = temp_dir.path();

        // Test when .gitignore doesn't exist
        assert!(!EnvFileGenerator::suggest_gitignore_update(worktree_path)?);

        // Create a .gitignore without .vibetree/
        let gitignore_path = worktree_path.join(".gitignore");
        fs::write(&gitignore_path, "*.log\n")?;

        assert!(!EnvFileGenerator::suggest_gitignore_update(worktree_path)?);

        // Add .vibetree/ to .gitignore
        EnvFileGenerator::add_to_gitignore(worktree_path)?;

        let content = fs::read_to_string(&gitignore_path)?;
        assert!(content.contains(".vibetree/"));
        assert!(EnvFileGenerator::suggest_gitignore_update(worktree_path)?);

        // Test idempotency - adding again shouldn't duplicate
        EnvFileGenerator::add_to_gitignore(worktree_path)?;
        let _content_after = fs::read_to_string(&gitignore_path)?;
        assert_eq!(content.matches(".vibetree/").count(), 1);

        Ok(())
    }
}
